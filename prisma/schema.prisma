generator client {
  provider = "prisma-client"
  output = "../generated/prisma_client"
}

datasource db {
  provider = "postgresql"
}

model Test {
  id    String @id @default(cuid())
  email String @unique
  name  String
}

model User {
  id            String  @id
  name          String
  email         String
  emailVerified Boolean @default(false)
  image         String?

  roleId String?
  role   Role?   @relation(fields: [roleId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions  Session[]
  accounts  Account[]
  students  Student[]
  isAllowed Boolean   @default(false)

  managedDormitories Dormitory[] @relation("DormitoryManager")

  @@unique([email])
  @@map("user")
}

model Role {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?

  users       User[]
  permissions RolePermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Permission {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?

  roles RolePermission[]

  createdAt DateTime @default(now())
}

model RolePermission {
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId]) // Composite Primary Key
  @@index([permissionId])
}



model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model FeeStructure {
  id String @id @default(cuid())

  departmentId String
  department   Department @relation(fields: [departmentId], references: [id])

  entranceYear String // "2025-2026"
  totalAmount  Float // 800$

  @@unique([departmentId, entranceYear])
}

model EducationalYear {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Back-references
  students           Student[]     @relation("EntranceYearStudent")
  installmentsByYear Installment[] @relation("InstallmentYear")
  installmentsByEntr Installment[] @relation("EntranceYear")
}

model Student {
  id          String  @id @default(cuid())
  studentCode String  @unique
  fullNameEn  String
  fullNameKu  String
  mobileNo    String
  gender      String
  email       String
  isActive    Boolean @default(true)

  departmentId String
  department   Department @relation(fields: [departmentId], references: [id])

  entranceYearId String
  entranceYear   EducationalYear @relation("EntranceYearStudent", fields: [entranceYearId], references: [id])

  payments Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?

  installmentReminders InstallmentReminder[]

  roomId String?
  room   Room?   @relation(fields: [roomId], references: [id])

  dormInsurances DormInsurance[]
}

model Dormitory {
  id          String    @id @default(cuid())
  title       String    @unique
  description String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  manager     User?     @relation("DormitoryManager", fields: [managerId], references: [id], onDelete: Cascade)
  managerId   String?
  rooms       Room[]
  expenses    Expense[]
}

model Room {
  id          String    @id @default(cuid())
  floorNumber Int
  roomNumber  Int
  capacity    Int       @default(4)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  dormId      String
  dormitory   Dormitory @relation(fields: [dormId], references: [id])
  students    Student[]

  @@unique([dormId, floorNumber, roomNumber])
  @@index([dormId])
}

model Department {
  id   String @id @default(cuid())
  name String @unique
  code String @unique

  students      Student[]
  feeStructures FeeStructure[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Installment {
  id String @id @default(cuid())

  title         String
  amount        Float
  installmentNo Int

  yearId String
  year   EducationalYear @relation("InstallmentYear", fields: [yearId], references: [id])

  entranceYearId String
  entranceYear   EducationalYear @relation("EntranceYear", fields: [entranceYearId], references: [id])

  startDate DateTime
  endDate   DateTime

  payments             Payment[]
  installmentReminders InstallmentReminder[]

  @@unique([yearId, installmentNo])
}

enum PaymentType {
  RECEIVE
  RETURN
  DISCOUNT
}

enum PaymentMethod {
  CASH
  FIB
  FASTPAY
}

model Payment {
  id String @id @default(cuid())

  studentId     String
  installmentId String
  paymentStatus String?

  note String?

  discountPercent Float?
  discountAmount  Float?
  receiptUrl      String?

  student     Student     @relation(fields: [studentId], references: [id])
  installment Installment @relation(fields: [installmentId], references: [id])

  amount        Float
  paymentType   PaymentType
  paymentMethod PaymentMethod
  createdBy     String?

  paidAt DateTime @default(now())

  @@index([studentId])
  @@index([installmentId])
  @@index([paidAt])
}

enum InsuranceStatus {
  ACTIVE // Student paid, currently in dormitory
  RETURNED // Left dormitory, insurance returned (full or partial)
  FORFEITED // Left dormitory, insurance kept (major issue)
}

model DormInsurance {
  id        String @id @default(cuid())
  studentId String

  // Payment in
  amountPaid    Float // What student paid (usually 100,000)
  paidAt        DateTime      @default(now())
  paymentMethod PaymentMethod // reuse your existing enum

  // Return info (filled when student leaves)
  amountReturned Float? // null until returned
  returnedAt     DateTime?
  returnNote     String? // e.g. "Broken chair, dirty bathroom"
  returnedBy     String? // admin userId who processed return

  status InsuranceStatus @default(ACTIVE)

  student Student @relation(fields: [studentId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([studentId])
}

enum OutgoingStatus {
  PENDING
  APPROVED
  REJECTED
}

model OutgoingPayment {
  id String @id @default(cuid())

  totalCollected   Float
  amountToHandOver Float
  remainingFloat   Float

  note          String?
  paymentMethod PaymentMethod

  periodStart DateTime?
  periodEnd   DateTime?

  status OutgoingStatus @default(PENDING)

  submittedBy String
  submittedAt DateTime @default(now())

  approvedBy    String?
  approvedAt    DateTime?
  rejectionNote String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([submittedBy])
}

model Category {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())

  expenses Expense[]
}

model Expense {
  id          String   @id @default(uuid())
  title       String
  amount      Float
  description String?
  date        DateTime @default(now())
  documentUrl String?

  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  dormId String?
  dorm   Dormitory? @relation(fields: [dormId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ReminderStage {
  FIRST
  FINAL
  OVERDUE // Optional: add more stages
}

model InstallmentReminder {
  id String @id @default(cuid())

  studentId     String
  installmentId String

  student     Student     @relation(fields: [studentId], references: [id])
  installment Installment @relation(fields: [installmentId], references: [id])

  reminderStage ReminderStage // Use enum instead of String
  sentAt        DateTime      @default(now())

  @@unique([studentId, installmentId, reminderStage])
}
